// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: student.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countStudentsByCollege = `-- name: CountStudentsByCollege :one
SELECT COUNT(*) as count
FROM students
WHERE college_id = $1
`

func (q *Queries) CountStudentsByCollege(ctx context.Context, collegeID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countStudentsByCollege, collegeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStudent = `-- name: CreateStudent :one
INSERT INTO students (
    user_id,
    college_id,
    kratos_identity_id,
    enrollment_year,
    roll_no,
    is_active,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING student_id, user_id, college_id, kratos_identity_id, enrollment_year, roll_no, is_active, created_at, updated_at
`

type CreateStudentParams struct {
	UserID           int32         `db:"user_id" json:"userId"`
	CollegeID        int32         `db:"college_id" json:"collegeId"`
	KratosIdentityID string        `db:"kratos_identity_id" json:"kratosIdentityId"`
	EnrollmentYear   sql.NullInt32 `db:"enrollment_year" json:"enrollmentYear"`
	RollNo           string        `db:"roll_no" json:"rollNo"`
	IsActive         bool          `db:"is_active" json:"isActive"`
	CreatedAt        time.Time     `db:"created_at" json:"createdAt"`
	UpdatedAt        time.Time     `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) CreateStudent(ctx context.Context, arg CreateStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, createStudent,
		arg.UserID,
		arg.CollegeID,
		arg.KratosIdentityID,
		arg.EnrollmentYear,
		arg.RollNo,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.UserID,
		&i.CollegeID,
		&i.KratosIdentityID,
		&i.EnrollmentYear,
		&i.RollNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteStudent = `-- name: DeleteStudent :exec
DELETE FROM students
WHERE student_id = $1 AND college_id = $2
`

type DeleteStudentParams struct {
	StudentID int32 `db:"student_id" json:"studentId"`
	CollegeID int32 `db:"college_id" json:"collegeId"`
}

func (q *Queries) DeleteStudent(ctx context.Context, arg DeleteStudentParams) error {
	_, err := q.db.Exec(ctx, deleteStudent, arg.StudentID, arg.CollegeID)
	return err
}

const findAllStudentsByCollege = `-- name: FindAllStudentsByCollege :many
SELECT student_id, user_id, college_id, kratos_identity_id, enrollment_year, roll_no, is_active, created_at, updated_at
FROM students
WHERE college_id = $1
ORDER BY roll_no ASC
LIMIT $2 OFFSET $3
`

type FindAllStudentsByCollegeParams struct {
	CollegeID int32 `db:"college_id" json:"collegeId"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

func (q *Queries) FindAllStudentsByCollege(ctx context.Context, arg FindAllStudentsByCollegeParams) ([]Student, error) {
	rows, err := q.db.Query(ctx, findAllStudentsByCollege, arg.CollegeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.StudentID,
			&i.UserID,
			&i.CollegeID,
			&i.KratosIdentityID,
			&i.EnrollmentYear,
			&i.RollNo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByKratosID = `-- name: FindByKratosID :one
SELECT student_id, user_id, college_id, kratos_identity_id, enrollment_year, roll_no, is_active, created_at, updated_at
FROM students
WHERE kratos_identity_id = $1
`

func (q *Queries) FindByKratosID(ctx context.Context, kratosIdentityID string) (Student, error) {
	row := q.db.QueryRow(ctx, findByKratosID, kratosIdentityID)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.UserID,
		&i.CollegeID,
		&i.KratosIdentityID,
		&i.EnrollmentYear,
		&i.RollNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const freezeStudent = `-- name: FreezeStudent :exec
UPDATE students
SET is_active = false,
    updated_at = NOW()
WHERE roll_no = $1
`

func (q *Queries) FreezeStudent(ctx context.Context, rollNo string) error {
	_, err := q.db.Exec(ctx, freezeStudent, rollNo)
	return err
}

const getStudentByID = `-- name: GetStudentByID :one
SELECT student_id, user_id, college_id, kratos_identity_id, enrollment_year, roll_no, is_active, created_at, updated_at
FROM students
WHERE student_id = $1 AND college_id = $2
`

type GetStudentByIDParams struct {
	StudentID int32 `db:"student_id" json:"studentId"`
	CollegeID int32 `db:"college_id" json:"collegeId"`
}

func (q *Queries) GetStudentByID(ctx context.Context, arg GetStudentByIDParams) (Student, error) {
	row := q.db.QueryRow(ctx, getStudentByID, arg.StudentID, arg.CollegeID)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.UserID,
		&i.CollegeID,
		&i.KratosIdentityID,
		&i.EnrollmentYear,
		&i.RollNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStudentByRollNo = `-- name: GetStudentByRollNo :one
SELECT student_id, user_id, college_id, kratos_identity_id, enrollment_year, roll_no, is_active, created_at, updated_at
FROM students
WHERE roll_no = $1 AND college_id = $2
`

type GetStudentByRollNoParams struct {
	RollNo    string `db:"roll_no" json:"rollNo"`
	CollegeID int32  `db:"college_id" json:"collegeId"`
}

func (q *Queries) GetStudentByRollNo(ctx context.Context, arg GetStudentByRollNoParams) (Student, error) {
	row := q.db.QueryRow(ctx, getStudentByRollNo, arg.RollNo, arg.CollegeID)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.UserID,
		&i.CollegeID,
		&i.KratosIdentityID,
		&i.EnrollmentYear,
		&i.RollNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unFreezeStudent = `-- name: UnFreezeStudent :exec
UPDATE students
SET is_active = true,
    updated_at = NOW()
WHERE roll_no = $1
`

func (q *Queries) UnFreezeStudent(ctx context.Context, rollNo string) error {
	_, err := q.db.Exec(ctx, unFreezeStudent, rollNo)
	return err
}

const updateStudent = `-- name: UpdateStudent :exec
UPDATE students
SET user_id = $1,
    college_id = $2,
    kratos_identity_id = $3,
    enrollment_year = $4,
    roll_no = $5,
    is_active = $6,
    updated_at = $7
WHERE student_id = $8
`

type UpdateStudentParams struct {
	UserID           int32         `db:"user_id" json:"userId"`
	CollegeID        int32         `db:"college_id" json:"collegeId"`
	KratosIdentityID string        `db:"kratos_identity_id" json:"kratosIdentityId"`
	EnrollmentYear   sql.NullInt32 `db:"enrollment_year" json:"enrollmentYear"`
	RollNo           string        `db:"roll_no" json:"rollNo"`
	IsActive         bool          `db:"is_active" json:"isActive"`
	UpdatedAt        time.Time     `db:"updated_at" json:"updatedAt"`
	StudentID        int32         `db:"student_id" json:"studentId"`
}

func (q *Queries) UpdateStudent(ctx context.Context, arg UpdateStudentParams) error {
	_, err := q.db.Exec(ctx, updateStudent,
		arg.UserID,
		arg.CollegeID,
		arg.KratosIdentityID,
		arg.EnrollmentYear,
		arg.RollNo,
		arg.IsActive,
		arg.UpdatedAt,
		arg.StudentID,
	)
	return err
}
