// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: attendance.sql

package repository

import (
	"context"
	"time"
)

const freezeAttendance = `-- name: FreezeAttendance :exec
UPDATE attendance
SET status = $1
WHERE college_id = $2 AND student_id = $3
`

type FreezeAttendanceParams struct {
	Status    string `db:"status" json:"status"`
	CollegeID int32  `db:"college_id" json:"collegeId"`
	StudentID int32  `db:"student_id" json:"studentId"`
}

func (q *Queries) FreezeAttendance(ctx context.Context, arg FreezeAttendanceParams) error {
	_, err := q.db.Exec(ctx, freezeAttendance, arg.Status, arg.CollegeID, arg.StudentID)
	return err
}

const getAttendanceByCourse = `-- name: GetAttendanceByCourse :many
SELECT id, student_id, course_id, college_id, date, status, scanned_at, lecture_id
FROM attendance
WHERE college_id = $1 AND course_id = $2
ORDER BY date DESC, student_id ASC
LIMIT $3 OFFSET $4
`

type GetAttendanceByCourseParams struct {
	CollegeID int32 `db:"college_id" json:"collegeId"`
	CourseID  int32 `db:"course_id" json:"courseId"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type GetAttendanceByCourseRow struct {
	ID        int32     `db:"id" json:"id"`
	StudentID int32     `db:"student_id" json:"studentId"`
	CourseID  int32     `db:"course_id" json:"courseId"`
	CollegeID int32     `db:"college_id" json:"collegeId"`
	Date      time.Time `db:"date" json:"date"`
	Status    string    `db:"status" json:"status"`
	ScannedAt time.Time `db:"scanned_at" json:"scannedAt"`
	LectureID int32     `db:"lecture_id" json:"lectureId"`
}

func (q *Queries) GetAttendanceByCourse(ctx context.Context, arg GetAttendanceByCourseParams) ([]GetAttendanceByCourseRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceByCourse,
		arg.CollegeID,
		arg.CourseID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceByCourseRow{}
	for rows.Next() {
		var i GetAttendanceByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.CourseID,
			&i.CollegeID,
			&i.Date,
			&i.Status,
			&i.ScannedAt,
			&i.LectureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceByLecture = `-- name: GetAttendanceByLecture :many
SELECT id, student_id, course_id, college_id, date, status, scanned_at, lecture_id
FROM attendance
WHERE college_id = $1 AND lecture_id = $2 AND course_id = $3
ORDER BY student_id ASC, scanned_at ASC
LIMIT $4 OFFSET $5
`

type GetAttendanceByLectureParams struct {
	CollegeID int32 `db:"college_id" json:"collegeId"`
	LectureID int32 `db:"lecture_id" json:"lectureId"`
	CourseID  int32 `db:"course_id" json:"courseId"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type GetAttendanceByLectureRow struct {
	ID        int32     `db:"id" json:"id"`
	StudentID int32     `db:"student_id" json:"studentId"`
	CourseID  int32     `db:"course_id" json:"courseId"`
	CollegeID int32     `db:"college_id" json:"collegeId"`
	Date      time.Time `db:"date" json:"date"`
	Status    string    `db:"status" json:"status"`
	ScannedAt time.Time `db:"scanned_at" json:"scannedAt"`
	LectureID int32     `db:"lecture_id" json:"lectureId"`
}

func (q *Queries) GetAttendanceByLecture(ctx context.Context, arg GetAttendanceByLectureParams) ([]GetAttendanceByLectureRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceByLecture,
		arg.CollegeID,
		arg.LectureID,
		arg.CourseID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceByLectureRow{}
	for rows.Next() {
		var i GetAttendanceByLectureRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.CourseID,
			&i.CollegeID,
			&i.Date,
			&i.Status,
			&i.ScannedAt,
			&i.LectureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceStudent = `-- name: GetAttendanceStudent :many
SELECT id, student_id, course_id, college_id, date, status, scanned_at, lecture_id
FROM attendance
WHERE college_id = $1 AND student_id = $2
ORDER BY date DESC, course_id ASC, scanned_at DESC
LIMIT $3 OFFSET $4
`

type GetAttendanceStudentParams struct {
	CollegeID int32 `db:"college_id" json:"collegeId"`
	StudentID int32 `db:"student_id" json:"studentId"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type GetAttendanceStudentRow struct {
	ID        int32     `db:"id" json:"id"`
	StudentID int32     `db:"student_id" json:"studentId"`
	CourseID  int32     `db:"course_id" json:"courseId"`
	CollegeID int32     `db:"college_id" json:"collegeId"`
	Date      time.Time `db:"date" json:"date"`
	Status    string    `db:"status" json:"status"`
	ScannedAt time.Time `db:"scanned_at" json:"scannedAt"`
	LectureID int32     `db:"lecture_id" json:"lectureId"`
}

func (q *Queries) GetAttendanceStudent(ctx context.Context, arg GetAttendanceStudentParams) ([]GetAttendanceStudentRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceStudent,
		arg.CollegeID,
		arg.StudentID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceStudentRow{}
	for rows.Next() {
		var i GetAttendanceStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.CourseID,
			&i.CollegeID,
			&i.Date,
			&i.Status,
			&i.ScannedAt,
			&i.LectureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceStudentInCourse = `-- name: GetAttendanceStudentInCourse :many
SELECT id, student_id, course_id, college_id, date, status, scanned_at, lecture_id
FROM attendance
WHERE college_id = $1 AND student_id = $2 AND course_id = $3
ORDER BY date DESC, scanned_at DESC
LIMIT $4 OFFSET $5
`

type GetAttendanceStudentInCourseParams struct {
	CollegeID int32 `db:"college_id" json:"collegeId"`
	StudentID int32 `db:"student_id" json:"studentId"`
	CourseID  int32 `db:"course_id" json:"courseId"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type GetAttendanceStudentInCourseRow struct {
	ID        int32     `db:"id" json:"id"`
	StudentID int32     `db:"student_id" json:"studentId"`
	CourseID  int32     `db:"course_id" json:"courseId"`
	CollegeID int32     `db:"college_id" json:"collegeId"`
	Date      time.Time `db:"date" json:"date"`
	Status    string    `db:"status" json:"status"`
	ScannedAt time.Time `db:"scanned_at" json:"scannedAt"`
	LectureID int32     `db:"lecture_id" json:"lectureId"`
}

func (q *Queries) GetAttendanceStudentInCourse(ctx context.Context, arg GetAttendanceStudentInCourseParams) ([]GetAttendanceStudentInCourseRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceStudentInCourse,
		arg.CollegeID,
		arg.StudentID,
		arg.CourseID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceStudentInCourseRow{}
	for rows.Next() {
		var i GetAttendanceStudentInCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.CourseID,
			&i.CollegeID,
			&i.Date,
			&i.Status,
			&i.ScannedAt,
			&i.LectureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAttendance = `-- name: MarkAttendance :one
INSERT INTO attendance (
    student_id,
    course_id,
    college_id,
    lecture_id,
    date,
    status,
    scanned_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (student_id, course_id, lecture_id, date, college_id)
DO UPDATE SET scanned_at = EXCLUDED.scanned_at, status = EXCLUDED.status
RETURNING id, student_id, course_id, college_id, lecture_id, date, status, scanned_at, created_at, updated_at
`

type MarkAttendanceParams struct {
	StudentID int32     `db:"student_id" json:"studentId"`
	CourseID  int32     `db:"course_id" json:"courseId"`
	CollegeID int32     `db:"college_id" json:"collegeId"`
	LectureID int32     `db:"lecture_id" json:"lectureId"`
	Date      time.Time `db:"date" json:"date"`
	Status    string    `db:"status" json:"status"`
	ScannedAt time.Time `db:"scanned_at" json:"scannedAt"`
}

func (q *Queries) MarkAttendance(ctx context.Context, arg MarkAttendanceParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, markAttendance,
		arg.StudentID,
		arg.CourseID,
		arg.CollegeID,
		arg.LectureID,
		arg.Date,
		arg.Status,
		arg.ScannedAt,
	)
	var i Attendance
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.CourseID,
		&i.CollegeID,
		&i.LectureID,
		&i.Date,
		&i.Status,
		&i.ScannedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setAttendanceStatus = `-- name: SetAttendanceStatus :exec
INSERT INTO attendance (
    student_id,
    course_id,
    college_id,
    lecture_id,
    status,
    scanned_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (student_id, course_id, college_id, lecture_id)
DO UPDATE SET status = EXCLUDED.status, scanned_at = EXCLUDED.scanned_at
`

type SetAttendanceStatusParams struct {
	StudentID int32     `db:"student_id" json:"studentId"`
	CourseID  int32     `db:"course_id" json:"courseId"`
	CollegeID int32     `db:"college_id" json:"collegeId"`
	LectureID int32     `db:"lecture_id" json:"lectureId"`
	Status    string    `db:"status" json:"status"`
	ScannedAt time.Time `db:"scanned_at" json:"scannedAt"`
}

func (q *Queries) SetAttendanceStatus(ctx context.Context, arg SetAttendanceStatusParams) error {
	_, err := q.db.Exec(ctx, setAttendanceStatus,
		arg.StudentID,
		arg.CourseID,
		arg.CollegeID,
		arg.LectureID,
		arg.Status,
		arg.ScannedAt,
	)
	return err
}

const unFreezeAttendance = `-- name: UnFreezeAttendance :exec
UPDATE attendance
SET status = $1
WHERE college_id = $2 AND student_id = $3 AND status = $4
`

type UnFreezeAttendanceParams struct {
	Status    string `db:"status" json:"status"`
	CollegeID int32  `db:"college_id" json:"collegeId"`
	StudentID int32  `db:"student_id" json:"studentId"`
	Status_2  string `db:"status_2" json:"status2"`
}

func (q *Queries) UnFreezeAttendance(ctx context.Context, arg UnFreezeAttendanceParams) error {
	_, err := q.db.Exec(ctx, unFreezeAttendance,
		arg.Status,
		arg.CollegeID,
		arg.StudentID,
		arg.Status_2,
	)
	return err
}

const updateAttendance = `-- name: UpdateAttendance :exec
UPDATE attendance
SET status = $1
WHERE college_id = $2 AND student_id = $3 AND course_id = $4 AND lecture_id = $5
`

type UpdateAttendanceParams struct {
	Status    string `db:"status" json:"status"`
	CollegeID int32  `db:"college_id" json:"collegeId"`
	StudentID int32  `db:"student_id" json:"studentId"`
	CourseID  int32  `db:"course_id" json:"courseId"`
	LectureID int32  `db:"lecture_id" json:"lectureId"`
}

func (q *Queries) UpdateAttendance(ctx context.Context, arg UpdateAttendanceParams) error {
	_, err := q.db.Exec(ctx, updateAttendance,
		arg.Status,
		arg.CollegeID,
		arg.StudentID,
		arg.CourseID,
		arg.LectureID,
	)
	return err
}
