version: '3'

vars:
  APP_NAME: edduhub
  COVERAGE_UNIT_OUT: coverage-unit.out
  COVERAGE_INTEGRATION_OUT: coverage-integration.out
  COVERAGE_MERGED_OUT: coverage-merged.out
  COVERAGE_HTML_OUT: coverage.html
  MIGRATE_PATH: server/db/migrations
  # Using TEST_DB_URL assuming this is for the test database based on the instructions
  TEST_DB_URL: postgres://keto:secret@localhost:5432/keto?sslmode=disable


tasks:
  default:
    desc: Run all tests (unit and integration)
    cmds:
      - task: test

  test:
    desc: Run both unit and integration tests
    deps: [test:unit, test:integration]

  test:unit:
    desc: Run unit tests
    cmds:
      - go test -tags=unit -race -coverprofile={{.COVERAGE_UNIT_OUT}} ./...

  test:integration:
    desc: Run integration tests (requires Docker running)
    cmds:
      - docker info > /dev/null || (echo "Docker is not running. Please start Docker." && exit 1)
      - go test -tags=integration -race -coverprofile={{.COVERAGE_INTEGRATION_OUT}} -v ./...

  cover:
    desc: Generate and view code coverage report (run after tests)
    deps: [cover:merge]
    cmds:
      - go tool cover -html={{.COVERAGE_MERGED_OUT}}
    silent: true

  cover:merge:
    desc: Merge unit and integration test coverage profiles
    cmds:
      - |
        if [ -f {{.COVERAGE_UNIT_OUT}} ] && [ -f {{.COVERAGE_INTEGRATION_OUT}} ]; then
          gocovmerge {{.COVERAGE_UNIT_OUT}} {{.COVERAGE_INTEGRATION_OUT}} > {{.COVERAGE_MERGED_OUT}}
        elif [ -f {{.COVERAGE_UNIT_OUT}} ]; then
          cp {{.COVERAGE_UNIT_OUT}} {{.COVERAGE_MERGED_OUT}}
        elif [ -f {{.COVERAGE_INTEGRATION_OUT}} ]; then
          cp {{.COVERAGE_INTEGRATION_OUT}} {{.COVERAGE_MERGED_OUT}}
        else
          echo "No coverage files found to merge."
          exit 1
        fi
      - echo "Coverage merged into {{.COVERAGE_MERGED_OUT}}"

  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run ./...

  tidy:
    desc: Run go mod tidy
    cmds:
      - go mod tidy -v

  build:
    desc: Build the main application binary
    cmds:
      - go build -o bin/{{.APP_NAME}} ./server

  clean:
    desc: Remove coverage files and built binary
    cmds:
      - rm -f {{.COVERAGE_UNIT_OUT}} {{.COVERAGE_INTEGRATION_OUT}} {{.COVERAGE_MERGED_OUT}} {{.COVERAGE_HTML_OUT}}
      - rm -f bin/{{.APP_NAME}}

  mocks:
    desc: Generate mocks for all interfaces using mockery
    cmds:
      - mockery 

  run:dev:
    desc: Run server with autoreload (requires air)
    cmds:
      - air

  docker:dev:
    desc: Start development environment with Docker Compose
    cmds:
      - docker-compose up --build

  fmt:
    desc: Format code using gofumpt and goimports
    cmds:
      - gofumpt -w .
      - goimports -w .

  swagger:
    desc: Generate Swagger OpenAPI docs (requires swag)
    cmds:
      - swag init -g server/main.go -o server/docs

  migrate:up:
    desc: "Apply database migrations to the test database"
    cmds:
      - migrate -path {{.MIGRATE_PATH}} -database {{.TEST_DB_URL}} up

  # ==============================================================================
  # BOOTSTRAP & SETUP TASKS
  # ==============================================================================

  check:env:
    desc: Check if required environment variables are set
    cmds:
      - |
        echo "Checking environment configuration..."
        if [ ! -f server/.env.local ]; then
          echo "‚ùå Missing server/.env.local"
          echo "   Run: cp server/.env.example server/.env.local && edit server/.env.local"
          exit 1
        fi
        echo "‚úì server/.env.local found"
        
        if [ ! -f client/.env.local ]; then
          echo "‚ö† Missing client/.env.local (creating from example)"
          cp client/.env.example client/.env.local
        fi
        echo "‚úì client/.env.local found"

  check:deps:
    desc: Check if required tools are installed
    cmds:
      - |
        echo "Checking required tools..."
        
        tools="go docker docker-compose node npm migrate"
        missing=""
        
        for tool in $tools; do
          if ! command -v $tool &> /dev/null; then
            missing="$missing $tool"
          else
            version=$($tool --version 2>&1 | head -n 1)
            echo "‚úì $tool: $version"
          fi
        done
        
        if [ ! -z "$missing" ]; then
          echo "‚ùå Missing tools:$missing"
          exit 1
        fi
        echo "‚úì All required tools found"

  setup:server:
    desc: Setup server environment (install deps, create .env)
    cmds:
      - task: check:env
      - |
        echo "Setting up server dependencies..."
        go mod download
        go mod tidy
        echo "‚úì Server dependencies ready"

  setup:client:
    desc: Setup client environment (install node dependencies)
    cmds:
      - |
        echo "Setting up client dependencies..."
        cd client
        npm install
        cd ..
        echo "‚úì Client dependencies ready"

  db:start:
    desc: Start database services (Docker Compose)
    cmds:
      - |
        echo "Starting database services..."
        docker-compose up -d postgres redis minio keto kratos-db kratos
        echo "Waiting for services to be healthy..."
        sleep 5
        docker-compose exec -T postgres pg_isready -U keto || echo "‚ö† PostgreSQL not ready yet"
        echo "‚úì Database services started"

  db:stop:
    desc: Stop database services
    cmds:
      - docker-compose down

  db:migrate:
    desc: Run all database migrations
    cmds:
      - |
        DB_URL="postgres://$(grep '^DB_USER=' server/.env.local | cut -d= -f2):$(grep '^DB_PASSWORD=' server/.env.local | cut -d= -f2)@localhost:$(grep '^DB_PORT=' server/.env.local | cut -d= -f2)/$(grep '^DB_NAME=' server/.env.local | cut -d= -f2)?sslmode=disable"
        echo "Running migrations..."
        migrate -path {{.MIGRATE_PATH}} -database "$DB_URL" up
        echo "‚úì Database migrations completed"

  db:reset:
    desc: Reset database (WARNING - drops all data)
    cmds:
      - |
        DB_URL="postgres://$(grep '^DB_USER=' server/.env.local | cut -d= -f2):$(grep '^DB_PASSWORD=' server/.env.local | cut -d= -f2)@localhost:$(grep '^DB_PORT=' server/.env.local | cut -d= -f2)/$(grep '^DB_NAME=' server/.env.local | cut -d= -f2)?sslmode=disable"
        echo "‚ö† WARNING: This will delete all data in the database"
        read -p "Are you sure? (type 'yes' to confirm): " confirm
        if [ "$confirm" = "yes" ]; then
          migrate -path {{.MIGRATE_PATH}} -database "$DB_URL" down
          migrate -path {{.MIGRATE_PATH}} -database "$DB_URL" up
          echo "‚úì Database reset completed"
        else
          echo "Cancelled"
        fi

  bootstrap:
    desc: Full bootstrap setup (deps, env, db, migrations)
    cmds:
      - echo "üöÄ Starting full bootstrap setup..."
      - task: check:deps
      - task: check:env
      - task: setup:server
      - task: setup:client
      - task: db:start
      - task: db:migrate
      - echo "‚úÖ Bootstrap complete! Run 'task dev' to start development"

  dev:
    desc: Start full development environment (server + client)
    cmds:
      - |
        echo "Starting development environment..."
        echo "Backend: http://localhost:8080"
        echo "Frontend: http://localhost:3000"
        echo "Swagger: http://localhost:8080/swagger/index.html"
        echo ""
        echo "Press Ctrl+C to stop both services"
        sleep 2
      - |
        (task run:dev) & (cd client && npm run dev)
        wait
    
  dev:server:
    desc: Start server only with hot reload
    cmds:
      - task: run:dev

  dev:client:
    desc: Start client only
    cmds:
      - cd client && npm run dev

  health:
    desc: Check health of running services
    cmds:
      - |
        echo "Checking service health..."
        echo ""
        
        echo "Backend API:"
        curl -s http://localhost:8080/api/health -I | head -n 1 || echo "‚ùå Backend not responding"
        
        echo ""
        echo "Frontend:"
        curl -s http://localhost:3000 -I | head -n 1 || echo "‚ö† Frontend not responding"
        
        echo ""
        echo "Database:"
        docker-compose exec -T postgres pg_isready -U keto || echo "‚ùå Database not responding"
        
        echo ""
        echo "Redis:"
        docker-compose exec -T redis redis-cli ping || echo "‚ùå Redis not responding"